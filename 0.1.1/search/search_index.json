{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"python-internal-lib-template","text":"<p>A template repo for internal python package.</p>"},{"location":"#contribution-workflow","title":"Contribution Workflow","text":"<pre><code>graph TB\n  f0[github:develop] --&gt;|pull latest changes + create| A1;\n  A1[github:feature-branchX] --&gt;|implement functionality + create| A2;\n  A2[github:PR-into-develop] --&gt;|pass all PR checks + request| A3;\n  A3[github:PR-review] --&gt;|on approval| A4;\n  A4[github:Merge] --&gt;|merge into develop branch| A5;\n  A5[github:PR-into-develop] --&gt;|sync the develop branch| A6;\n  A6[github:PR-into-main] --&gt;|pass all PR checks + request| A7;\n  A7[github:Merge] --&gt;|builds and publishes package on| B1([aws_account:deployment]);</code></pre>"},{"location":"pages/calculators/","title":"Sample Usage","text":"<p>Commonly Used Classes and Methods</p> <p>Instead of writing docstrings and examples for every tiny method and class,  let us just focus on ones that are for primary use such as the dsutilities.data_extraction.timeseries_api.timeseriesgetter.TimeSeriesGetter and its primary method get_timeseries(tag_list). </p>"},{"location":"pages/calculators/#apiutils.sample_modules.calculators.Calculator","title":"<code>Calculator</code>","text":"<p>simple calculator class as a template.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>a magic number.</p> required <code>b</code> <code>int</code> <p>a magic number.</p> required Source code in <code>apiutils/sample_modules/calculators.py</code> <pre><code>class Calculator:\n    \"\"\"simple calculator class as a template.\n\n    Args:\n        a (int): a magic number.\n        b (int): a magic number.\n\n    \"\"\"\n\n    @staticmethod\n    def add(a: int, b: int) -&gt; int:\n        \"\"\"Add two magic numbers together.\n\n        Example:\n            &gt;&gt;&gt; res = Calculator(1, 2).add()\n            1 + 2 = 3\n\n        Returns:\n            int: sum of two magic numbers.\n        \"\"\"\n        return a + b\n</code></pre>"},{"location":"pages/calculators/#apiutils.sample_modules.calculators.Calculator.add","title":"<code>add(a, b)</code>  <code>staticmethod</code>","text":"<p>Add two magic numbers together.</p> Example <p>res = Calculator(1, 2).add() 1 + 2 = 3</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>sum of two magic numbers.</p> Source code in <code>apiutils/sample_modules/calculators.py</code> <pre><code>@staticmethod\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two magic numbers together.\n\n    Example:\n        &gt;&gt;&gt; res = Calculator(1, 2).add()\n        1 + 2 = 3\n\n    Returns:\n        int: sum of two magic numbers.\n    \"\"\"\n    return a + b\n</code></pre>"},{"location":"pages/weather_api/","title":"WeatherApi","text":""},{"location":"pages/weather_api/#apiutils.weather_api.GetWeatherData","title":"<code>GetWeatherData</code>","text":"<p>Get data from external api for specific location. </p> <p>Methods:</p> Name Description <code>get_data</code> <p>Get Weather data for specific locations</p> <p>Parameters:</p> Name Type Description Default <code>user_defined_config</code> <code>ApiConfig</code> <p>Class with configuration details</p> <code>None</code> <code>max_workers</code> <code>int</code> <p>Number of threads</p> <code>8</code> <code>max_retries</code> <code>int</code> <p>Number of retries for API calls</p> <code>3</code> <code>allow_failure</code> <code>bool</code> <p>If False, non existing locations will be returned as empty list</p> <code>True</code> <p>Raises:</p> Type Description <code>Exception</code> <p>BASE_URL not defined</p> <p>Examples:</p> <p>weather_api = GetWeatherData() weather_api.get_data(locations=['location1', 'location2'])</p> Source code in <code>apiutils/weather_api.py</code> <pre><code>class GetWeatherData:\n    \"\"\"\n    Get data from external api for specific location. \n\n    Methods:\n        get_data: Get Weather data for specific locations\n\n    Args:\n        user_defined_config (ApiConfig): Class with configuration details\n        max_workers (int): Number of threads\n        max_retries (int): Number of retries for API calls\n        allow_failure (bool): If False, non existing locations will be returned as empty list\n\n    Raises:\n        Exception: BASE_URL not defined\n\n    Examples:\n        weather_api = GetWeatherData()\n        weather_api.get_data(locations=['location1', 'location2'])\n    \"\"\"\n\n    def __init__(\n        self,\n        user_defined_config: Optional[ApiConfig] = None,\n        max_workers: int = 8,\n        max_retries: int = 3,\n        allow_failure: bool = True,\n    ):\n        if user_defined_config is None:\n            config = ApiConfig()\n        else:\n            config = user_defined_config\n\n        self.token_handler = TokenHandler(config)\n        self.base_url = config.base_url\n\n        self.data = defaultdict(list)\n\n        self.headers = None\n        self.params = None\n\n        self.max_workers = max_workers\n        self.max_retries = max_retries\n        self.allow_failure = allow_failure\n\n    def _urljoin(self, elems: List[str]) -&gt; str:\n        \"\"\"\n        Join elements to an url\n\n        Args:\n            elems (List[str]): List of url elements\n\n        Returns:\n            str: Joined url elements\n\n        Examples:\n            urljoin(['https://www.john.com', 'bla', 'ola'])\n            'https://www.john.com/bla/ola'\n        \"\"\"\n\n        return \"/\".join(map(lambda x: str(x).strip(\"/\"), elems))\n\n    def _reset_data(self) -&gt; None:\n        \"\"\"\n        Reset data - will be called before each separate api call\n        \"\"\"\n\n        logger.info(\"Reset data\")\n\n        self.data = defaultdict(list)\n\n        return None\n\n    def _set_header(self) -&gt; None:\n        \"\"\"\n        Checks if token is available and sets header for authentication\n\n        Args:\n            None\n\n        Returns:\n            None\n\n        raises:\n            Exception: No Authentication Token found\n        \"\"\"\n        logger.info(\"Set header token for Authentication\")\n\n        token = self.token_handler.get_token()\n\n        if token:\n            self.headers = {\"Authorization\": f\"Bearer {token}\"}\n        else:\n            raise ex.NoAuthentication(\"No Authentication Token found\")\n\n    def get_requests(self, urls: List[Dict]) -&gt; None:\n        \"\"\"\n        Get requests for urls - calls threaded requests defined by max_workers\n\n        This method will be called by every api method. Data from previous calls\n        will be deleted!\n\n        Args:\n            urls (List[Dict]): List with location and url\n        \"\"\"\n        self._reset_data()\n\n        if self.headers is None:\n            self._set_header()\n\n        max_workers = max(1, min(self.max_workers, len(urls)))\n\n        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n            _ = executor.map(self.get_request, urls)\n\n        return None\n\n    def get_request(self, url: Dict) -&gt; None:\n        \"\"\"\n        Gets data from url and stores it in self.data. Allowing multiple retries.\n\n        Args:\n            url (Dict): Dict with location and url\n\n        Raises:\n            Exception: If max_retries is reached\n        \"\"\"\n\n        failed_retries = 0\n\n        _location = url.get(\"location\")\n        logger.info(f\"Get Request for weather forecast of location: {_location}\")\n\n        session = requests.Session()  \n        session.headers = self.headers\n\n        params = copy(self.params)\n\n        while failed_retries &lt; self.max_retries:\n            response = self._get_request(session, url.get(\"url\"), params)\n\n            if response.status_code != 200:\n                status_code = response.status_code\n                text = f\"Retry request for {_location} because {response.text}\"\n\n                logging.error(ex.ApiException(status_code, text))\n\n                if response.status_code == 403:\n                    self._set_header()\n                    session.headers = self.headers\n\n                failed_retries += 1\n\n                continue\n\n            response = json.loads(response.text)\n\n            self._update_data(response, _location)\n\n\n        if failed_retries &gt;= self.max_retries:\n            raise ex.ApiException(response.status_code, response.text)\n\n        return None\n\n    def _get_request(\n        self, session: requests.Session, url: str, params: Dict\n    ) -&gt; requests.Response:\n        \"\"\"\n        Get request for url \n\n        Args:\n            session (requests.Session): Session object\n            url (str): Url for API call\n\n        Returns:\n            requests.Response: Response from API call\n        \"\"\"\n        logger.info(f\"API call for url: {url}\")\n\n        try:\n            response = session.get(url, params=params, verify=False, timeout=60)\n\n        except Exception as e:\n            raise e\n\n        return response\n\n    def _update_data(self, response: Dict, _location: str) -&gt; None:\n        \"\"\"\n        Update data with response \n\n        Args:\n            response (Dict): Response from API call\n            _location (str): location\n\n        Returns:\n            None\n        \"\"\"\n\n        logger.info(f\"Update data for location: {_location}\")\n\n        self.data[_location].append(response)\n\n        return None\n\n    def _manipulate_data(self, locations: Union[List[str], str]) -&gt; None:\n        \"\"\"\n        Non existing locations will be manipulated to return an empty list\n\n        This assures, that all locations in the request will be present in the output\n\n        Args:\n            locations (Union[List[str], str]): List of locations\n\n        Returns:\n            None\n\n        Examples:\n            self.data = {'location1': [\"test\"]}\n            _manipulate_data(locations=['location1', 'location2'])\n            self.data = {'location1': [\"test\"], 'location2': []}\n        \"\"\"\n        if isinstance(locations, str):\n            locations = [locations]\n\n        for _location in locations:\n            if _location in self.data:\n                continue\n\n            self.data[_location] = []\n\n        return None\n\n\n    def get_data(self, locations: Union[List[str], str], params={}) -&gt; dm.WeatherDataOutput:\n        \"\"\"\n        Get data for specific locations by calling the external api\n\n        Args:\n            locations (Union[List[str], str]): List of locations\n            params (Dict): Parameters for API endpoint call\n\n        Returns:\n            Dict: WeatherDataOutput\n        \"\"\"\n        if isinstance(locations, str):\n            locations = [locations]\n\n        self.params = dm.ApiDataParams(**params).model_dump(exclude_none=True)\n\n        urls = []\n\n        for _location in locations:\n            temp = {\n                \"location\": _location,\n                \"url\": self._urljoin([self.base_url,  _location, \"data\"]),\n            }\n            urls.append(temp)\n\n        self.get_requests(urls)\n\n        if not self.allow_failure:\n            self._manipulate_data(locations)\n\n        return dm.WeatherDataOutput(**self.data).model_dump()\n</code></pre>"},{"location":"pages/weather_api/#apiutils.weather_api.GetWeatherData.get_data","title":"<code>get_data(locations, params={})</code>","text":"<p>Get data for specific locations by calling the external api</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>Union[List[str], str]</code> <p>List of locations</p> required <code>params</code> <code>Dict</code> <p>Parameters for API endpoint call</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>WeatherDataOutput</code> <p>WeatherDataOutput</p> Source code in <code>apiutils/weather_api.py</code> <pre><code>def get_data(self, locations: Union[List[str], str], params={}) -&gt; dm.WeatherDataOutput:\n    \"\"\"\n    Get data for specific locations by calling the external api\n\n    Args:\n        locations (Union[List[str], str]): List of locations\n        params (Dict): Parameters for API endpoint call\n\n    Returns:\n        Dict: WeatherDataOutput\n    \"\"\"\n    if isinstance(locations, str):\n        locations = [locations]\n\n    self.params = dm.ApiDataParams(**params).model_dump(exclude_none=True)\n\n    urls = []\n\n    for _location in locations:\n        temp = {\n            \"location\": _location,\n            \"url\": self._urljoin([self.base_url,  _location, \"data\"]),\n        }\n        urls.append(temp)\n\n    self.get_requests(urls)\n\n    if not self.allow_failure:\n        self._manipulate_data(locations)\n\n    return dm.WeatherDataOutput(**self.data).model_dump()\n</code></pre>"},{"location":"pages/weather_api/#apiutils.weather_api.GetWeatherData.get_request","title":"<code>get_request(url)</code>","text":"<p>Gets data from url and stores it in self.data. Allowing multiple retries.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Dict</code> <p>Dict with location and url</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If max_retries is reached</p> Source code in <code>apiutils/weather_api.py</code> <pre><code>def get_request(self, url: Dict) -&gt; None:\n    \"\"\"\n    Gets data from url and stores it in self.data. Allowing multiple retries.\n\n    Args:\n        url (Dict): Dict with location and url\n\n    Raises:\n        Exception: If max_retries is reached\n    \"\"\"\n\n    failed_retries = 0\n\n    _location = url.get(\"location\")\n    logger.info(f\"Get Request for weather forecast of location: {_location}\")\n\n    session = requests.Session()  \n    session.headers = self.headers\n\n    params = copy(self.params)\n\n    while failed_retries &lt; self.max_retries:\n        response = self._get_request(session, url.get(\"url\"), params)\n\n        if response.status_code != 200:\n            status_code = response.status_code\n            text = f\"Retry request for {_location} because {response.text}\"\n\n            logging.error(ex.ApiException(status_code, text))\n\n            if response.status_code == 403:\n                self._set_header()\n                session.headers = self.headers\n\n            failed_retries += 1\n\n            continue\n\n        response = json.loads(response.text)\n\n        self._update_data(response, _location)\n\n\n    if failed_retries &gt;= self.max_retries:\n        raise ex.ApiException(response.status_code, response.text)\n\n    return None\n</code></pre>"},{"location":"pages/weather_api/#apiutils.weather_api.GetWeatherData.get_requests","title":"<code>get_requests(urls)</code>","text":"<p>Get requests for urls - calls threaded requests defined by max_workers</p> <p>This method will be called by every api method. Data from previous calls will be deleted!</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>List[Dict]</code> <p>List with location and url</p> required Source code in <code>apiutils/weather_api.py</code> <pre><code>def get_requests(self, urls: List[Dict]) -&gt; None:\n    \"\"\"\n    Get requests for urls - calls threaded requests defined by max_workers\n\n    This method will be called by every api method. Data from previous calls\n    will be deleted!\n\n    Args:\n        urls (List[Dict]): List with location and url\n    \"\"\"\n    self._reset_data()\n\n    if self.headers is None:\n        self._set_header()\n\n    max_workers = max(1, min(self.max_workers, len(urls)))\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        _ = executor.map(self.get_request, urls)\n\n    return None\n</code></pre>"}]}